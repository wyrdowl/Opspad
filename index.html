<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
  <title>OpsPad — Viz + Range + Sensors</title>
  <style>
    :root { --bg:#0a0a0a; --panel:#131316; --muted:#a1a1aa; --text:#fafafa; --accent:#ffffff; --border:#27272a; }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { height: 100%; }
    body { margin:0; background:var(--bg); color:var(--text); font-family: system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif; }
    .wrap { display:flex; flex-direction:column; min-height:100dvh; }
    header { position:sticky; top:0; z-index:10; padding:16px 16px 8px; background:linear-gradient(180deg, rgba(10,10,10,0.9), rgba(10,10,10,0)); backdrop-filter: blur(6px); }
    h1 { margin:0; font-size:20px; font-weight:800; letter-spacing:-0.01em; }
    main { flex:1; padding:16px; padding-bottom:148px; }
    .tabs { position:fixed; left:0; right:0; bottom:0; background:#0f0f13; border-top:1px solid var(--border); display:grid; grid-template-columns:repeat(7,1fr); }
    .tab { padding:10px 4px; text-align:center; color:#a1a1aa; font-size:11px; }
    .tab.active { color:#fff; }
    .card { background:var(--panel); border:1px solid var(--border); border-radius:16px; padding:12px; }
    .row { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .btn { background:var(--accent); color:#111; font-weight:700; padding:10px 14px; border-radius:12px; border:none; }
    .btn.ghost { background:#1b1b21; color:#e5e5e5; border:1px solid var(--border); }
    input, textarea, select { width:100%; background:#111116; border:1px solid var(--border); color:#fafafa; border-radius:12px; padding:12px; font-size:14px; }
    label.sm { font-size:12px; color:#a1a1aa; }
    ul { list-style:none; padding:0; margin:0; }
    .pill { width:18px; height:18px; border-radius:50%; border:1.5px solid #6b7280; display:grid; place-items:center; }
    .strike { text-decoration: line-through; opacity:0.6; }
    .grid { display:grid; place-items:center; gap:12px; }
    .center { text-align:center; color:#a1a1aa; font-size:13px; }
    .num { font-variant-numeric: tabular-nums; }
    .hidden { display:none; }

    /* Viz canvases */
    #viz-canvas { width:100%; height:340px; border-radius:16px; background: radial-gradient(1200px 600px at 20% 0%, #121219 0%, #0a0a0a 60%); border:1px solid var(--border); }
    #gyro-canvas{ width:100%; height:180px; border-radius:16px; border:1px solid var(--border); background:#0b0f18; }
    #badge-inverted { position:absolute; right:12px; top:12px; font-size:11px; background:#b00020; color:#fff; padding:4px 8px; border-radius:999px; display:none; }

    /* Rangefinder */
    .range-wrap { position:relative; }
    #range-video { width:100%; height:360px; object-fit:cover; border-radius:16px; border:1px solid var(--border); background:#000; }
    .range-overlay { position:absolute; inset:0; pointer-events:none; border-radius:16px; }
    .range-crosshair { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:140px; height:140px; border:1px solid rgba(255,255,255,0.45); border-radius:50%; }
    .range-crosshair:before, .range-crosshair:after { content:""; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); background:rgba(255,255,255,0.7); }
    .range-crosshair:before { width:1px; height:120px; }
    .range-crosshair:after  { width:120px; height:1px; }
    .range-hud { position:absolute; left:12px; top:12px; background:rgba(0,0,0,0.35); color:#fff; font-size:12px; padding:6px 8px; border-radius:10px; backdrop-filter: blur(4px); }
    .range-bottom { position:absolute; left:12px; right:12px; bottom:12px; display:flex; justify-content:space-between; gap:10px; pointer-events:none; }
    .range-tag { background:rgba(0,0,0,0.35); color:#fff; font-size:12px; padding:6px 8px; border-radius:10px; }

    /* Sensors table */
    .kv { display:grid; grid-template-columns: 140px 1fr; gap:8px 12px; align-items:center; }
    .kv .k { color:#c9c9d6; font-size:12px; }
    .kv .v { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:13px; }
    .section-title { font-size:12px; color:#c9c9d6; text-transform:uppercase; letter-spacing:0.12em; margin:4px 0 6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>OpsPad</h1>
      <div class="center" style="font-size:12px;">offline-first • local only</div>
    </header>

    <main>
      <!-- Tasks -->
      <section id="view-tasks">
        <form id="task-form" class="row">
          <input id="task-input" placeholder="Add a task…"/>
          <button class="btn" type="submit">Add</button>
        </form>
        <div class="row" style="margin-top:8px; justify-content:space-between;">
          <span id="remaining" class="num">0 remaining</span>
          <button id="clear-done" class="btn ghost">Clear done</button>
        </div>
        <ul id="task-list" class="mt"></ul>
      </section>

      <!-- Notes -->
      <section id="view-notes" class="hidden">
        <form id="note-form">
          <input id="note-title" placeholder="Title (optional)"/>
          <div class="spacer"></div>
          <textarea id="note-body" rows="4" placeholder="Write a note…"></textarea>
          <div class="mt" style="text-align:right;"><button class="btn" type="submit">Save</button></div>
        </form>
        <ul id="note-list" class="mt"></ul>
      </section>

      <!-- Timer -->
      <section id="view-timer" class="hidden">
        <div class="grid">
          <svg width="220" height="220" viewBox="0 0 120 120" class="progress">
            <circle cx="60" cy="60" r="54" stroke="#27272a" stroke-width="12" fill="none"></circle>
            <circle id="timer-progress" cx="60" cy="60" r="54" stroke="#ffffff" stroke-width="12" stroke-linecap="round" fill="none" stroke-dasharray="339.292" stroke-dashoffset="0"></circle>
          </svg>
          <div id="timer-readout" class="num" style="font-size:40px; font-weight:800;">25:00</div>
          <div class="row">
            <button id="timer-start" class="btn">Start</button>
            <button id="timer-reset" class="btn ghost">Reset</button>
          </div>
          <div class="card" style="width:100%;">
            <div class="center" style="font-size:12px;">Timer length (minutes)</div>
            <input type="range" id="timer-range" min="5" max="90" value="25" style="width:100%;"/>
            <div id="timer-mins" class="center" style="font-size:12px;">25 minutes</div>
          </div>
        </div>
      </section>

      <!-- BPM -->
      <section id="view-bpm" class="hidden">
        <div class="grid">
          <div class="center" style="text-transform:uppercase; letter-spacing:0.2em;">Average BPM</div>
          <div id="bpm-value" class="num" style="font-size:46px; font-weight:900;">—</div>
          <div id="bpm-ms" class="center" style="font-size:12px;"></div>
          <button id="bpm-tap" class="btn" style="width:160px; height:160px; border-radius:999px; font-size:24px;">TAP</button>
          <button id="bpm-reset" class="btn ghost">Reset</button>
          <div class="center" style="font-size:12px;">Tip: tap 5–8 times</div>
        </div>
      </section>

      <!-- Spectrum Visualizer -->
      <section id="view-viz" class="hidden">
        <div class="card" style="display:flex; flex-direction:column; gap:12px; position:relative;">
          <span id="badge-inverted">INVERTED</span>
          <canvas id="viz-canvas"></canvas>

          <div class="row">
            <button id="viz-start" class="btn">Start Mic</button>
            <button id="viz-stop" class="btn ghost">Stop</button>

            <label class="sm" for="viz-sens">Sensitivity</label>
            <input type="range" id="viz-sens" min="0.6" max="2.5" step="0.1" value="1.2" style="width:160px;"/>

            <label class="sm" for="viz-mode">Mode</label>
            <select id="viz-mode">
              <option value="bars">Bars</option>
              <option value="circle" selected>Circle</option>
            </select>

            <label class="sm" for="viz-circle">Circle size</label>
            <input type="range" id="viz-circle" min="0.18" max="0.45" step="0.01" value="0.28" style="width:150px;"/>

            <button id="viz-gyro" class="btn ghost">Enable Sensors</button>
          </div>

          <div class="row">
            <label class="sm" for="viz-palette">Palette</label>
            <select id="viz-palette">
              <option value="neon" selected>Neon</option>
              <option value="fireice">Fire/Ice</option>
              <option value="sunset">Sunset</option>
              <option value="matrix">Matrix</option>
              <option value="custom">Custom…</option>
            </select>

            <div id="custom-colors" class="row hidden">
              <label class="sm">Low</label><input type="color" id="c-low" value="#4da3ff"/>
              <label class="sm">Mid</label><input type="color" id="c-mid" value="#00f59a"/>
              <label class="sm">High</label><input type="color" id="c-high" value="#ff4dff"/>
            </div>
          </div>

          <div id="viz-status" class="center" style="font-size:12px;"></div>

          <div class="card" style="display:flex; flex-direction:column; gap:8px;">
            <div class="row" style="justify-content:space-between; flex-wrap:wrap;">
              <div class="sm">Gyro attitude (artificial horizon)</div>
              <div class="sm num" id="gyro-readout">pitch 0°, roll 0° • heading — • face —</div>
            </div>
            <canvas id="gyro-canvas"></canvas>
          </div>
        </div>
      </section>

      <!-- Range Finder -->
      <section id="view-range" class="hidden">
        <div class="card">
          <div class="range-wrap">
            <video id="range-video" playsinline muted autoplay></video>
            <div class="range-overlay">
              <div class="range-hud" id="range-hud">pitch —° • depression —°</div>
              <div class="range-crosshair"></div>
              <div class="range-bottom">
                <div class="range-tag" id="range-distance">distance —</div>
                <div class="range-tag" id="range-face">face —</div>
              </div>
            </div>
          </div>

          <div class="row" style="margin-top:10px;">
            <button id="range-start" class="btn">Start Camera</button>
            <button id="range-stop" class="btn ghost">Stop</button>

            <button id="range-sensors" class="btn ghost">Enable Sensors</button>

            <label class="sm" for="range-height">Height (m)</label>
            <input type="range" id="range-height" min="0.3" max="2.5" step="0.01" value="1.60" style="width:160px;"/>

            <label class="sm" for="range-units">Units</label>
            <select id="range-units">
              <option value="m" selected>meters</option>
              <option value="ft">feet</option>
            </select>

            <button id="range-cal" class="btn ghost">Calibrate</button>
            <button id="range-lock" class="btn ghost">Lock</button>
          </div>

          <div class="center" id="range-status" style="font-size:12px; margin-top:6px;"></div>
        </div>
      </section>

      <!-- Sensors (new) -->
      <section id="view-sensors" class="">
        <div class="card" style="display:flex; flex-direction:column; gap:12px;">
          <div class="row">
            <button id="sns-orient" class="btn ghost">Enable Orientation</button>
            <button id="sns-magnet" class="btn ghost">Enable Magnetometer</button>
            <button id="sns-light" class="btn ghost">Enable Ambient Light</button>
            <button id="sns-gps" class="btn ghost">Enable GPS</button>
          </div>

          <div id="sns-status" class="center" style="font-size:12px;"></div>

          <div class="section-title">Orientation & Accelerometer</div>
          <div class="kv">
            <div class="k">Pitch / Roll</div><div class="v" id="sns-pr">— / — deg</div>
            <div class="k">Heading</div><div class="v" id="sns-head">— (—)</div>
            <div class="k">Face</div><div class="v" id="sns-face">—</div>
          </div>

          <div class="section-title">Magnetometer</div>
          <div class="kv">
            <div class="k">x / y / z</div><div class="v" id="sns-mag">—</div>
            <div class="k">|B|</div><div class="v" id="sns-mag-mag">—</div>
            <div class="k">Status</div><div class="v" id="sns-mag-status">Not started</div>
          </div>

          <div class="section-title">Ambient Light</div>
          <div class="kv">
            <div class="k">Illuminance</div><div class="v" id="sns-lux">—</div>
            <div class="k">Status</div><div class="v" id="sns-lux-status">Not started</div>
          </div>

          <div class="section-title">GPS</div>
          <div class="kv">
            <div class="k">Lat / Lon</div><div class="v" id="sns-ll">—</div>
            <div class="k">Accuracy</div><div class="v" id="sns-acc">—</div>
            <div class="k">Altitude</div><div class="v" id="sns-alt">—</div>
            <div class="k">Speed / Heading</div><div class="v" id="sns-speed">—</div>
            <div class="k">Status</div><div class="v" id="sns-gps-status">Not started</div>
          </div>

          <div class="section-title">Pressure</div>
          <div class="kv">
            <div class="k">Barometer</div><div class="v">Not available in browsers (use native app or BLE barometer)</div>
          </div>
        </div>
      </section>
    </main>

    <nav class="tabs">
      <button class="tab" data-tab="tasks">Tasks</button>
      <button class="tab" data-tab="notes">Notes</button>
      <button class="tab" data-tab="timer">Timer</button>
      <button class="tab" data-tab="bpm">BPM</button>
      <button class="tab" data-tab="viz">Viz</button>
      <button class="tab" data-tab="range">Range</button>
      <button class="tab active" data-tab="sensors">Sensors</button>
    </nav>
  </div>

  <script>
    const $ = s=>document.querySelector(s), $$=s=>Array.from(document.querySelectorAll(s));
    const storage = { get(k,f){try{return JSON.parse(localStorage.getItem(k))??f;}catch{return f;}}, set(k,v){try{localStorage.setItem(k,JSON.stringify(v));}catch{}} };

    // Tabs
    const sections={tasks:$("#view-tasks"),notes:$("#view-notes"),timer:$("#view-timer"),bpm:$("#view-bpm"),viz:$("#view-viz"),range:$("#view-range"),sensors:$("#view-sensors")};
    $$(".tabs .tab").forEach(b=>b.addEventListener("click",()=>{const t=b.dataset.tab; $$(".tabs .tab").forEach(x=>x.classList.remove("active")); b.classList.add("active"); Object.keys(sections).forEach(k=>sections[k].classList.toggle("hidden",k!==t));}));

    // ---------- Helpers
    function degreesToCardinal(deg){
      if(deg==null || isNaN(deg)) return "—";
      const dirs=["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW","N"];
      return dirs[Math.round(deg/22.5)];
    }

    // ---------- Tasks
    let tasks=storage.get("opspad:tasks",[]); const taskList=$("#task-list"), taskInput=$("#task-input"), remaining=$("#remaining");
    const uid=()=>Math.random().toString(36).slice(2,9);
    function renderTasks(){ taskList.innerHTML=""; if(!tasks.length){const li=document.createElement("li"); li.className="center"; li.textContent="No tasks yet. Add your first one above."; taskList.appendChild(li);} else { tasks.forEach(t=>{ const li=document.createElement("li"); li.className="card"; const row=document.createElement("div"); row.className="row"; const pill=document.createElement("button"); pill.className="pill"; if(t.done){pill.style.background="#fff"; pill.style.borderColor="#fff";} pill.addEventListener("click",()=>{t.done=!t.done; storage.set("opspad:tasks",tasks); renderTasks();}); const txt=document.createElement("div"); txt.style.flex="1"; txt.style.fontSize="14px"; txt.textContent=t.text; if(t.done) txt.classList.add("strike"); const del=document.createElement("button"); del.className="btn ghost"; del.textContent="Delete"; del.addEventListener("click",()=>{tasks=tasks.filter(x=>x.id!==t.id); storage.set("opspad:tasks",tasks); renderTasks();}); row.appendChild(pill); row.appendChild(txt); row.appendChild(del); li.appendChild(row); taskList.appendChild(li);}); }
      remaining.textContent=`${tasks.filter(x=>!x.done).length} remaining`; }
    $("#task-form").addEventListener("submit",e=>{e.preventDefault(); const v=taskInput.value.trim(); if(!v) return; tasks.unshift({id:uid(),text:v,done:false,ts:Date.now()}); storage.set("opspad:tasks",tasks); taskInput.value=""; renderTasks();});
    $("#clear-done").addEventListener("click",()=>{tasks=tasks.filter(x=>!x.done); storage.set("opspad:tasks",tasks); renderTasks();}); renderTasks();

    // ---------- Notes
    let notes=storage.get("opspad:notes",[]); const noteList=$("#note-list"), noteForm=$("#note-form"), noteTitle=$("#note-title"), noteBody=$("#note-body");
    function renderNotes(){ noteList.innerHTML=""; if(!notes.length){const li=document.createElement("li"); li.className="center"; li.textContent="No notes yet. Write your first one above."; noteList.appendChild(li);} else { notes.forEach(n=>{ const li=document.createElement("li"); li.className="card"; const row=document.createElement("div"); row.className="row"; row.style.alignItems="start"; const col=document.createElement("div"); if(n.title){const h=document.createElement("div"); h.style.fontWeight="700"; h.style.fontSize="14px"; h.textContent=n.title; col.appendChild(h);} const p=document.createElement("div"); p.style.fontSize="14px"; p.style.whiteSpace="pre-wrap"; p.textContent=n.body; col.appendChild(p); const del=document.createElement("button"); del.className="btn ghost"; del.textContent="Delete"; del.addEventListener("click",()=>{notes=notes.filter(x=>x.id!==n.id); storage.set("opspad:notes",notes); renderNotes();}); row.appendChild(col); row.appendChild(del); li.appendChild(row); noteList.appendChild(li);}); } }
    noteForm.addEventListener("submit",e=>{e.preventDefault(); const t=noteTitle.value.trim(), b=noteBody.value.trim(); if(!t&&!b) return; notes.unshift({id:uid(),title:t,body:b,ts:Date.now()}); storage.set("opspad:notes",notes); noteTitle.value=""; noteBody.value=""; renderNotes();}); renderNotes();

    // ---------- Timer
    let dur=storage.get("opspad:timer:dur",25*60), left=storage.get("opspad:timer:left",dur), running=storage.get("opspad:timer:run",false); let raf=null,last=null;
    const range=$("#timer-range"), readout=$("#timer-readout"), minsLbl=$("#timer-mins"), circle=$("#timer-progress");
    const R=54, C=2*Math.PI*R; circle.setAttribute("stroke-dasharray",String(C));
    function fmt(s){const m=Math.floor(s/60), sec=Math.floor(s%60); return String(m).padStart(2,"0")+":"+String(sec).padStart(2,"0");}
    function drawTimer(){ readout.textContent=fmt(left); circle.setAttribute("stroke-dashoffset", String(C - C*Math.max(0,Math.min(1,left/dur)))); }
    function tick(ts){ if(last==null) last=ts; const dt=(ts-last)/1000; last=ts; left=Math.max(0,left-dt); storage.set("opspad:timer:left",left); drawTimer(); if(left<=0){ running=false; storage.set("opspad:timer:run",running); last=null; $("#timer-start").textContent="Start"; return;} raf=requestAnimationFrame(tick);}
    $("#timer-start").addEventListener("click",()=>{ if(!running){ if(left<=0) left=dur; running=true; storage.set("opspad:timer:run",running); raf=requestAnimationFrame(tick); $("#timer-start").textContent="Pause"; } else { running=false; storage.set("opspad:timer:run",running); cancelAnimationFrame(raf); last=null; $("#timer-start").textContent="Start"; }});
    $("#timer-reset").addEventListener("click",()=>{ running=false; storage.set("opspad:timer:run",running); cancelAnimationFrame(raf); last=null; left=dur; storage.set("opspad:timer:left",left); drawTimer(); $("#timer-start").textContent="Start";});
    range.value=Math.round(dur/60); minsLbl.textContent=`${range.value} minutes`; range.addEventListener("input",()=>{ dur=Number(range.value)*60; storage.set("opspad:timer:dur",dur); left=dur; storage.set("opspad:timer:left",left); minsLbl.textContent=`${range.value} minutes`; drawTimer();}); drawTimer(); if(running){ $("#timer-start").textContent="Pause"; raf=requestAnimationFrame(tick); }

    // ---------- BPM
    let taps=[]; const bpmValue=$("#bpm-value"), bpmMs=$("#bpm-ms");
    function updateBPM(){ if(taps.length<2){ bpmValue.textContent="—"; bpmMs.textContent=""; return; } const diffs=taps.slice(1).map((x,i)=>x-taps[i]); const mean=diffs.reduce((a,b)=>a+b,0)/diffs.length; const bpm=60000/mean; bpmValue.textContent=String(Math.round(bpm*10)/10); bpmMs.textContent=`~${Math.round((60000/bpm)*100)/100} ms per beat`; }
    $("#bpm-tap").addEventListener("click",()=>{ taps=[...taps,performance.now()].slice(-8); updateBPM(); if(navigator.vibrate) navigator.vibrate(10); const b=$("#bpm-tap"); b.style.transform="scale(0.96)"; setTimeout(()=>b.style.transform="",90); }); $("#bpm-reset").addEventListener("click",()=>{taps=[]; updateBPM();});

    // ---------- Palette helpers (Viz)
    const palettes = {
      neon:   ["#4da3ff","#00f59a","#ff4dff"],
      fireice:["#00e0ff","#4d6dff","#ff8a3d","#ff2e2e"],
      sunset: ["#7c4dff","#ff4db8","#ff8a3d"],
      matrix: ["#0a2a0a","#00ff6a","#0a2a0a"]
    };
    function hexToRgb(hex){ hex=hex.replace("#",""); if(hex.length===3){hex=hex.split("").map(c=>c+c).join("");} const n=parseInt(hex,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; }
    function lerp(a,b,t){ return a+(b-a)*t; }
    function lerpColor(c1,c2,t){ return { r:Math.round(lerp(c1.r,c2.r,t)), g:Math.round(lerp(c1.g,c2.g,t)), b:Math.round(lerp(c1.b,c2.b,t)) }; }
    function colorFromStops(stops,t){ const n=stops.length-1; const x=Math.max(0,Math.min(n-1,Math.floor(t*n))); const local=(t*n)-x; const c1=hexToRgb(stops[x]), c2=hexToRgb(stops[x+1]); const c=lerpColor(c1,c2,local); return c; }
    function mix(c,withC,amt){ return { r:Math.round(lerp(c.r,withC.r,amt)), g:Math.round(lerp(c.g,withC.g,amt)), b:Math.round(lerp(c.b,withC.b,amt)) }; }
    function rgbStr(c,a=1){ return `rgba(${c.r},${c.g},${c.b},${a})`; }

    // ---------- Viz (bars/circle + horizon & invert)
    ;(function(){
      const statusEl=$("#viz-status"), canvas=$("#viz-canvas"), ctx=canvas.getContext("2d",{alpha:false});
      const badgeInv=$("#badge-inverted");
      const sensEl=$("#viz-sens"), modeEl=$("#viz-mode"), circleEl=$("#viz-circle");
      const palEl=$("#viz-palette"), customWrap=$("#custom-colors"), cLow=$("#c-low"), cMid=$("#c-mid"), cHigh=$("#c-high");

      let audioCtx=null, analyser=null, source=null, stream=null, data=null, prev=null;
      let sensitivity=parseFloat(sensEl.value), rot=0;
      let circleSize=Number(storage.get("opspad:viz:circle", parseFloat(circleEl.value)));
      circleEl.value=String(circleSize);
      palEl.value = storage.get("opspad:viz:palette","neon");
      const savedCustom = storage.get("opspad:viz:custom",[cLow.value,cMid.value,cHigh.value]); [cLow.value,cMid.value,cHigh.value]=savedCustom; if(palEl.value==="custom") customWrap.classList.remove("hidden");

      const gyroBtn=$("#viz-gyro"), gyroCanvas=$("#gyro-canvas"), gtx=gyroCanvas.getContext("2d"); let sensorsOn=false, rafGyro=null;
      let orient={alpha:null,beta:0,gamma:0,heading:null}; let accel={x:0,y:0,z:0,face:"—"};

      function sizeCanvas(el, ctx){ const dpr=Math.max(1,Math.min(3,window.devicePixelRatio||1)); const r=el.getBoundingClientRect(); el.width=Math.floor(r.width*dpr); el.height=Math.floor(r.height*dpr); ctx.setTransform(dpr,0,0,dpr,0,0); }
      sizeCanvas(canvas,ctx); new ResizeObserver(()=>sizeCanvas(canvas,ctx)).observe(canvas);
      sizeCanvas(gyroCanvas,gtx); new ResizeObserver(()=>sizeCanvas(gyroCanvas,gtx)).observe(gyroCanvas);

      function updateFace(){ const z=accel.z||0, ax=accel.x||0, ay=accel.y||0; const absZ=Math.abs(z), absX=Math.abs(ax), absY=Math.abs(ay); accel.face=(absZ>6 && absZ>absX && absZ>absY)?(z<0?"face up":"face down"):"vertical"; badgeInv.style.display = (accel.face==="face down") ? "inline-block" : "none"; }

      function onOrientation(e){
        const a=(typeof e.webkitCompassHeading==="number") ? (360 - e.webkitCompassHeading) % 360 : (e.alpha ?? null);
        orient.alpha=a; orient.beta=e.beta||0; orient.gamma=e.gamma||0;
        if(a!=null){ let h=a; if(h<0) h+=360; if(h>=360) h-=360; orient.heading=h; }
      }
      function onMotion(e){ const a=e.accelerationIncludingGravity||e.acceleration||null; if(!a) return; accel.x=a.x||0; accel.y=a.y||0; accel.z=a.z||0; updateFace(); }

      async function enableSensors(){
        try{
          if(typeof DeviceMotionEvent!=="undefined" && typeof DeviceMotionEvent.requestPermission==="function"){ const r1=await DeviceMotionEvent.requestPermission(); if(r1!=="granted"){ statusEl.textContent="Motion permission denied."; return; } }
          if(typeof DeviceOrientationEvent!=="undefined" && typeof DeviceOrientationEvent.requestPermission==="function"){ try{ await DeviceOrientationEvent.requestPermission(); }catch{} }
          window.addEventListener("deviceorientation", onOrientation, true);
          window.addEventListener("devicemotion", onMotion, true);
          sensorsOn=true; gyroBtn.textContent="Sensors: On"; statusEl.textContent="Sensors enabled."; drawHorizon();
        }catch(err){ statusEl.textContent="Sensor error: "+(err.message||err); }
      }
      function disableSensors(){ window.removeEventListener("deviceorientation", onOrientation, true); window.removeEventListener("devicemotion", onMotion, true); sensorsOn=false; gyroBtn.textContent="Enable Sensors"; statusEl.textContent="Sensors off."; cancelAnimationFrame(rafGyro); drawHorizon(true); }
      gyroBtn.addEventListener("click", ()=> sensorsOn?disableSensors():enableSensors());

      function drawHorizon(stop=false){
        const w=gyroCanvas.clientWidth, h=gyroCanvas.clientHeight; gtx.clearRect(0,0,w,h);
        const cx=w/2, cy=h/2, pitch=Math.max(-60,Math.min(60,orient.beta||0)), roll=orient.gamma||0, heading=orient.heading;
        const invert=(accel.face==="face down"); const rollRad=(roll*Math.PI/180)+(invert?Math.PI:0); const scale=3; const offset=(invert?-pitch:pitch)*scale;
        gtx.save(); gtx.translate(cx,cy); gtx.rotate(rollRad);
        if(!invert){ gtx.fillStyle="#0d1f4a"; gtx.fillRect(-w,-h*2+offset,w*2,h*2); gtx.fillStyle="#3a2412"; gtx.fillRect(-w,0+offset,w*2,h*2); }
        else { gtx.fillStyle="#3a2412"; gtx.fillRect(-w,-h*2+offset,w*2,h*2); gtx.fillStyle="#0d1f4a"; gtx.fillRect(-w,0+offset,w*2,h*2); }
        gtx.strokeStyle="#fff"; gtx.lineWidth=2; gtx.beginPath(); gtx.moveTo(-w,offset); gtx.lineTo(w,offset); gtx.stroke(); gtx.restore();
        $("#gyro-readout").textContent=`pitch ${Math.round(pitch)}°, roll ${Math.round(roll)}° • heading ${heading!=null?Math.round(heading):"—"}° ${degreesToCardinal(heading)} • ${accel.face||"—"}`;
        if(!stop && sensorsOn) rafGyro=requestAnimationFrame(()=>drawHorizon(false));
      }
      drawHorizon(true);

      function getStops(){ const p=palEl.value; return p==="custom"?[cLow.value,cMid.value,cHigh.value]:(palettes[p]||palettes.neon); }
      function colorFor(i,bins,amp,dv){ const t=i/(bins-1); let c=colorFromStops(getStops(),t); if(dv>0.06) c=mix(c,{r:255,g:180,b:60},Math.min(0.8,dv*1.2)); else if(dv<-0.06) c=mix(c,{r:0,g:220,b:255},Math.min(0.8,-dv*1.2)); return rgbStr(c,1); }

      function drawBars(w,h,bins){
        const barGap=1, barW=Math.max(1,Math.floor(w/bins)-barGap);
        const sway = sensorsOn ? (orient.gamma||0)*0.25 : 0;
        ctx.shadowBlur=12; ctx.shadowColor="rgba(255,255,255,0.22)";
        for(let i=0;i<bins;i++){ const v=data[i]/255, amp=Math.pow(v*sensitivity,1.1); const y=Math.max(1,amp*h); const px=Math.floor(i*(barW+barGap)+(sway*(i/bins-0.5))), py=h-y; const dv=prev?(data[i]-prev[i])/255:0; ctx.fillStyle=colorFor(i,bins,amp,dv); ctx.fillRect(px,py,barW,y); }
      }
      function drawCircle(w,h,bins){
        const cx=w/2, cy=h/2, minSide=Math.min(w,h), baseR=minSide*circleSize, maxR=minSide*Math.min(0.49,circleSize+0.20);
        const targetRot=(sensorsOn?((orient.gamma||0)*Math.PI/180*0.75):0) + (badgeInv.style.display==="inline-block"?Math.PI:0);
        rot += (targetRot-rot)*0.08;
        ctx.save(); ctx.translate(cx,cy); ctx.rotate(rot); ctx.lineCap="round"; ctx.shadowBlur=14; ctx.shadowColor="rgba(255,255,255,0.22)";
        for(let i=0;i<bins;i++){ const v=data[i]/255, amp=Math.pow(v*sensitivity,1.05); const r1=baseR, r2=Math.min(maxR, baseR+amp*(maxR-baseR)); const a=(i/bins)*Math.PI*2; const x1=Math.cos(a)*r1, y1=Math.sin(a)*r1; const x2=Math.cos(a)*r2, y2=Math.sin(a)*r2; const dv=prev?(data[i]-prev[i])/255:0; ctx.strokeStyle=colorFor(i,bins,amp,dv); ctx.lineWidth=2+amp*3; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
        ctx.restore();
      }

      function draw(){
        if(!analyser) return;
        analyser.getByteFrequencyData(data);
        ctx.globalCompositeOperation="source-over"; ctx.fillStyle="rgba(10,10,12,0.10)"; ctx.fillRect(0,0,canvas.width,canvas.height);
        const w=canvas.clientWidth,h=canvas.clientHeight,bins=data.length;
        (modeEl.value==="bars")?drawBars(w,h,bins):drawCircle(w,h,bins);
        prev = (prev && prev.length===data.length) ? prev : new Uint8Array(bins); prev.set(data);
        requestAnimationFrame(draw);
      }

      async function start(){
        if(!(window.isSecureContext||location.hostname==="localhost"||location.hostname==="127.0.0.1")){ statusEl.textContent="Mic needs HTTPS or localhost."; return; }
        if(stream) return;
        try{
          statusEl.textContent="Requesting microphone…";
          stream=await navigator.mediaDevices.getUserMedia({audio:true});
          audioCtx=new (window.AudioContext||window.webkitAudioContext)();
          analyser=audioCtx.createAnalyser(); analyser.fftSize=1024; analyser.smoothingTimeConstant=0.85;
          source=audioCtx.createMediaStreamSource(stream); source.connect(analyser);
          data=new Uint8Array(analyser.frequencyBinCount); prev=new Uint8Array(analyser.frequencyBinCount);
          statusEl.textContent="Live (tap Stop to end)."; draw();
        }catch(err){ statusEl.textContent="Mic error: "+(err.message||err.name||err); }
      }
      function stop(){ if(source){try{source.disconnect();}catch{} source=null; } if(analyser) analyser=null; if(audioCtx){try{audioCtx.close();}catch{} audioCtx=null; } if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; } statusEl.textContent="Stopped."; }

      $("#viz-start").addEventListener("click",start);
      $("#viz-stop").addEventListener("click",stop);
      sensEl.addEventListener("input",e=>{ sensitivity=parseFloat(e.target.value); });
      circleEl.addEventListener("input",e=>{ const v=parseFloat(e.target.value); storage.set("opspad:viz:circle",v); circleSize=v; });
      palEl.addEventListener("change",e=>{ storage.set("opspad:viz:palette",e.target.value); customWrap.classList.toggle("hidden",e.target.value!=="custom"); });
      [cLow,cMid,cHigh].forEach(inp=>inp.addEventListener("input",()=>{ storage.set("opspad:viz:custom",[cLow.value,cMid.value,cHigh.value]); }));

      document.addEventListener("visibilitychange",()=>{ if(document.hidden) stop(); });
      window.addEventListener("pagehide",stop);
    })();

    // ---------- Range Finder
    ;(function(){
      const v=$("#range-video"), startBtn=$("#range-start"), stopBtn=$("#range-stop"), sensorsBtn=$("#range-sensors");
      const heightEl=$("#range-height"), unitsEl=$("#range-units"), calBtn=$("#range-cal"), lockBtn=$("#range-lock");
      const hud=$("#range-hud"), distEl=$("#range-distance"), faceEl=$("#range-face"), statusEl=$("#range-status");
      let stream=null, sensorsOn=false, locked=false; let pitch=0, face="—"; let zeroPitch=0; let height=parseFloat(heightEl.value); let units=unitsEl.value; let filteredPitch=0; const alpha=0.12;

      function toFeet(m){ return m*3.28084; }
      function fmtDist(m){ const u=unitsEl.value; const val=(u==="m")?m:toFeet(m); const unit=(u==="m")?" m":" ft"; return `${(val<10?val.toFixed(2):val.toFixed(1))}${unit}`; }

      async function startCam(){ try{ if(!(window.isSecureContext||location.hostname==="localhost"||location.hostname==="127.0.0.1")){ statusEl.textContent="Camera needs HTTPS or localhost."; return; } stream=await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ideal:"environment"} }, audio:false }); v.srcObject=stream; await v.play(); statusEl.textContent="Camera live. Aim crosshair at base of target."; }catch(err){ statusEl.textContent="Camera error: "+(err.message||err.name||err); } }
      function stopCam(){ if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; } v.srcObject=null; statusEl.textContent="Camera stopped."; }

      function onMotion(e){ const a=e.accelerationIncludingGravity||e.acceleration||null; if(!a) return; const z=a.z||0, ax=a.x||0, ay=a.y||0; const absZ=Math.abs(z), absX=Math.abs(ax), absY=Math.abs(ay); face=(absZ>6&&absZ>absX&&absZ>absY)?(z<0?"face up":"face down"):"vertical"; faceEl.textContent=face; }
      function onOrient(e){ const b=e.beta||0; const p=(face==="face down")?-b:b; filteredPitch += (p - filteredPitch)*alpha; pitch=filteredPitch; }

      async function enableSensors(){ try{ if(typeof DeviceMotionEvent!=="undefined" && typeof DeviceMotionEvent.requestPermission==="function"){ const r=await DeviceMotionEvent.requestPermission(); if(r!=="granted"){ statusEl.textContent="Motion permission denied."; return; } } if(typeof DeviceOrientationEvent!=="undefined" && typeof DeviceOrientationEvent.requestPermission==="function"){ try{ await DeviceOrientationEvent.requestPermission(); }catch{} } window.addEventListener("devicemotion", onMotion, true); window.addEventListener("deviceorientation", onOrient, true); sensorsOn=true; sensorsBtn.textContent="Sensors: On"; statusEl.textContent="Sensors enabled."; }catch(err){ statusEl.textContent="Sensor error: "+(err.message||err); } }
      function disableSensors(){ window.removeEventListener("devicemotion", onMotion, true); window.removeEventListener("deviceorientation", onOrient, true); sensorsOn=false; sensorsBtn.textContent="Enable Sensors"; statusEl.textContent="Sensors off."; }

      function compute(){ const depression = (pitch - zeroPitch); hud.textContent=`pitch ${Math.round(pitch)}° • depression ${Math.round(depression)}°`; if(locked) return; if(Math.abs(depression)<1 || depression<=0){ distEl.textContent="distance —"; return; } const rad=depression*Math.PI/180; const dist=height/Math.tan(rad); distEl.textContent = isFinite(dist)&&dist<10000 ? `distance ${fmtDist(dist)}` : "distance —"; requestAnimationFrame(compute); }
      compute();

      startBtn.addEventListener("click", startCam);
      stopBtn.addEventListener("click", stopCam);
      sensorsBtn.addEventListener("click", ()=> sensorsOn?disableSensors():enableSensors());
      heightEl.addEventListener("input", e=>{ height=parseFloat(e.target.value); });
      unitsEl.addEventListener("change", ()=>{ /* auto updates */ });
      calBtn.addEventListener("click", ()=>{ zeroPitch=pitch; statusEl.textContent=`Calibrated at ${Math.round(zeroPitch)}°`; });
      lockBtn.addEventListener("click", ()=>{ locked=!locked; lockBtn.textContent=locked?"Unlock":"Lock"; });
    })();

    // ---------- Sensors Tab (Magnetometer / Ambient Light / GPS)
    ;(function(){
      const st=$("#sns-status");
      const bOrient=$("#sns-orient"), bMag=$("#sns-magnet"), bLux=$("#sns-light"), bGps=$("#sns-gps");
      const vPR=$("#sns-pr"), vHead=$("#sns-head"), vFace=$("#sns-face");
      const vMag=$("#sns-mag"), vMagMag=$("#sns-mag-mag"), vMagStatus=$("#sns-mag-status");
      const vLux=$("#sns-lux"), vLuxStatus=$("#sns-lux-status");
      const vLL=$("#sns-ll"), vAcc=$("#sns-acc"), vAlt=$("#sns-alt"), vSpeed=$("#sns-speed"), vGpsStatus=$("#sns-gps-status");

      // Orientation + accel
      let orientOn=false;
      function onOrient(e){
        const a=(typeof e.webkitCompassHeading==="number") ? (360 - e.webkitCompassHeading) % 360 : (e.alpha ?? null);
        const pitch=e.beta||0, roll=e.gamma||0;
        vPR.textContent = `${Math.round(pitch)} / ${Math.round(roll)} deg`;
        const head = (a!=null)? ((a<0)?a+360: (a>=360?a-360:a)) : null;
        vHead.textContent = head!=null ? `${Math.round(head)}° (${degreesToCardinal(head)})` : "— (—)";
      }
      let face="—";
      function onMotion(e){
        const a=e.accelerationIncludingGravity||e.acceleration||null; if(!a) return;
        const z=a.z||0, ax=a.x||0, ay=a.y||0; const absZ=Math.abs(z), absX=Math.abs(ax), absY=Math.abs(ay);
        face=(absZ>6 && absZ>absX && absZ>absY) ? (z<0 ? "face up" : "face down") : "vertical";
        vFace.textContent = face;
      }
      async function toggleOrient(){
        if(!orientOn){
          try{
            if(typeof DeviceMotionEvent!=="undefined" && typeof DeviceMotionEvent.requestPermission==="function"){ const r=await DeviceMotionEvent.requestPermission(); if(r!=="granted"){ st.textContent="Motion permission denied."; return; } }
            if(typeof DeviceOrientationEvent!=="undefined" && typeof DeviceOrientationEvent.requestPermission==="function"){ try{ await DeviceOrientationEvent.requestPermission(); }catch{} }
            window.addEventListener("deviceorientation", onOrient, true);
            window.addEventListener("devicemotion", onMotion, true);
            orientOn=true; bOrient.textContent="Orientation: On"; st.textContent="Orientation enabled.";
          }catch(err){ st.textContent="Orientation error: "+(err.message||err); }
        }else{
          window.removeEventListener("deviceorientation", onOrient, true);
          window.removeEventListener("devicemotion", onMotion, true);
          orientOn=false; bOrient.textContent="Enable Orientation"; st.textContent="Orientation off.";
        }
      }
      bOrient.addEventListener("click", toggleOrient);

      // Magnetometer
      let magSensor=null;
      function startMag(){
        if(!('Magnetometer' in window)){ vMagStatus.textContent="Unsupported in this browser."; return; }
        try{
          magSensor = new Magnetometer({frequency:10});
          magSensor.addEventListener('reading', ()=>{
            const x=magSensor.x||0, y=magSensor.y||0, z=magSensor.z||0;
            const mag = Math.sqrt(x*x+y*y+z*z);
            vMag.textContent = `${x.toFixed(1)} / ${y.toFixed(1)} / ${z.toFixed(1)} µT`;
            vMagMag.textContent = `${mag.toFixed(1)} µT`;
          });
          magSensor.addEventListener('error', e=>{ vMagStatus.textContent = `Error: ${e.error && e.error.name ? e.error.name : e.message || e}`; });
          magSensor.start();
          vMagStatus.textContent="Running";
          bMag.textContent="Magnetometer: On";
        }catch(err){
          vMagStatus.textContent="Failed to start (permissions or policy).";
        }
      }
      function stopMag(){ if(magSensor){ try{ magSensor.stop(); }catch{} magSensor=null; } vMagStatus.textContent="Stopped"; bMag.textContent="Enable Magnetometer"; }
      bMag.addEventListener("click", ()=> magSensor?stopMag():startMag());

      // Ambient Light
      let luxSensor=null;
      function startLux(){
        if(!('AmbientLightSensor' in window)){ vLuxStatus.textContent="Unsupported in this browser."; return; }
        try{
          luxSensor = new AmbientLightSensor({frequency:5});
          luxSensor.addEventListener('reading', ()=>{ vLux.textContent = `${luxSensor.illuminance.toFixed(1)} lux`; });
          luxSensor.addEventListener('error', e=>{ vLuxStatus.textContent = `Error: ${e.error && e.error.name ? e.error.name : e.message || e}`; });
          luxSensor.start();
          vLuxStatus.textContent="Running";
          bLux.textContent="Ambient Light: On";
        }catch(err){ vLuxStatus.textContent="Failed to start (permissions or policy)."; }
      }
      function stopLux(){ if(luxSensor){ try{ luxSensor.stop(); }catch{} luxSensor=null; } vLuxStatus.textContent="Stopped"; bLux.textContent="Enable Ambient Light"; }
      bLux.addEventListener("click", ()=> luxSensor?stopLux():startLux());

      // GPS
      let watchId=null;
      function startGPS(){
        if(!('geolocation' in navigator)){ vGpsStatus.textContent="Geolocation not supported."; return; }
        watchId = navigator.geolocation.watchPosition(pos=>{
          const {latitude, longitude, accuracy, altitude, altitudeAccuracy, speed, heading} = pos.coords;
          vLL.textContent = `${latitude.toFixed(6)}, ${longitude.toFixed(6)}`;
          vAcc.textContent = `${Math.round(accuracy)} m`;
          vAlt.textContent = (altitude!=null) ? `${altitude.toFixed(1)} m` + (altitudeAccuracy!=null? ` (±${Math.round(altitudeAccuracy)} m)`:"") : "—";
          const sp = (speed!=null && isFinite(speed)) ? `${speed.toFixed(1)} m/s (${(speed*3.6).toFixed(1)} km/h)` : "—";
          const hd = (heading!=null && isFinite(heading)) ? `${Math.round(heading)}° (${degreesToCardinal(heading)})` : "—";
          vSpeed.textContent = `${sp} • ${hd}`;
          vGpsStatus.textContent = `Watching (accuracy ±${Math.round(accuracy)} m)`;
        }, err=>{
          vGpsStatus.textContent = `Error: ${err.message}`;
        }, { enableHighAccuracy:true, maximumAge:2000, timeout:10000 });
        bGps.textContent="GPS: On";
      }
      function stopGPS(){ if(watchId!=null){ navigator.geolocation.clearWatch(watchId); watchId=null; } vGpsStatus.textContent="Stopped"; bGps.textContent="Enable GPS"; }
      bGps.addEventListener("click", ()=> watchId!=null?stopGPS():startGPS());
    })();
  </script>
</body>
</html>
